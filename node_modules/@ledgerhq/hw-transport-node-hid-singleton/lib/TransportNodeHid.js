"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_hid_1 = __importDefault(require("node-hid"));
const hw_transport_node_hid_noevents_1 = __importStar(require("@ledgerhq/hw-transport-node-hid-noevents"));
const logs_1 = require("@ledgerhq/logs");
const devices_1 = require("@ledgerhq/devices");
const errors_1 = require("@ledgerhq/errors");
const listenDevices_1 = require("./listenDevices");
const LOG_TYPE = "hid-verbose";
let transportInstance = null;
const DISCONNECT_AFTER_INACTIVITY_TIMEOUT_MS = 5000;
/**
 * node-hid Transport implementation
 * @example
 * import TransportNodeHid from "@ledgerhq/hw-transport-node-hid-singleton";
 * ...
 * TransportNodeHid.create().then(transport => ...)
 */
class TransportNodeHidSingleton extends hw_transport_node_hid_noevents_1.default {
    constructor(device, { context } = {}) {
        super(device, { context, logType: LOG_TYPE });
    }
    /**
     *
     */
    static isSupported = hw_transport_node_hid_noevents_1.default.isSupported;
    /**
     *
     */
    static list = hw_transport_node_hid_noevents_1.default.list;
    /**
     */
    static listen = (observer) => {
        let unsubscribed;
        Promise.resolve((0, hw_transport_node_hid_noevents_1.getDevices)()).then(devices => {
            // this needs to run asynchronously so the subscription is defined during this phase
            for (const device of devices) {
                if (!unsubscribed) {
                    const deviceModel = (0, devices_1.identifyUSBProductId)(device.productId);
                    observer.next({
                        type: "add",
                        descriptor: "",
                        device: {
                            name: device.deviceName,
                        },
                        deviceModel,
                    });
                }
            }
        });
        const onAdd = device => {
            const deviceModel = (0, devices_1.identifyUSBProductId)(device.productId);
            observer.next({
                type: "add",
                descriptor: "",
                deviceModel,
                device: {
                    name: device.deviceName,
                },
            });
        };
        const onRemove = device => {
            const deviceModel = (0, devices_1.identifyUSBProductId)(device.productId);
            observer.next({
                type: "remove",
                descriptor: "",
                deviceModel,
                device: {
                    name: device.deviceName,
                },
            });
        };
        const stop = (0, listenDevices_1.listenDevices)(onAdd, onRemove);
        function unsubscribe() {
            stop();
            unsubscribed = true;
        }
        return {
            unsubscribe,
        };
    };
    static disconnectAfterInactivityTimeout;
    static clearDisconnectAfterInactivityTimeout() {
        if (TransportNodeHidSingleton.disconnectAfterInactivityTimeout) {
            clearTimeout(TransportNodeHidSingleton.disconnectAfterInactivityTimeout);
        }
    }
    /**
     * Disconnects device from singleton instance after some inactivity (no new `open`).
     *
     * Currently, there is only one transport instance (for only one device connected via USB).
     */
    static setDisconnectAfterInactivityTimeout() {
        TransportNodeHidSingleton.clearDisconnectAfterInactivityTimeout();
        TransportNodeHidSingleton.disconnectAfterInactivityTimeout = setTimeout(() => {
            (0, logs_1.trace)({
                type: LOG_TYPE,
                message: "Disconnecting after inactivity, if not prevented",
                data: {
                    hasInstance: Boolean(transportInstance),
                },
            });
            if (transportInstance) {
                TransportNodeHidSingleton.disconnect();
            }
        }, DISCONNECT_AFTER_INACTIVITY_TIMEOUT_MS);
    }
    /**
     * Disconnects from the HID device associated to the transport singleton.
     *
     * If you want to try to re-use the same transport instance at the next action (when calling `open` again), you can use
     * the transport instance `close` method: it will only enable a disconnect after some inactivity.
     */
    static disconnect() {
        (0, logs_1.trace)({
            type: LOG_TYPE,
            message: "Disconnecting from HID device",
            data: {
                hasInstance: Boolean(transportInstance),
            },
        });
        TransportNodeHidSingleton.clearDisconnectAfterInactivityTimeout();
        if (transportInstance) {
            transportInstance.device.close();
            (0, logs_1.trace)({
                type: LOG_TYPE,
                message: `Closed HID communication with device. Emitting "disconnect" event from static disconnect and clearing singleton instance`,
            });
            transportInstance.emit("disconnect");
            transportInstance = null;
        }
    }
    /**
     * Connects to the first Ledger device connected via USB
     *
     * Reusing the same TransportNodeHidSingleton instance until a disconnection happens.
     * Pitfall: this implementation only handles 1 device connected via USB
     *
     * Legacy: `_descriptor` is needed to follow the Transport definition
     */
    static open(_descriptor, _timeoutMs, context) {
        const tracer = new logs_1.LocalTracer(LOG_TYPE, context);
        TransportNodeHidSingleton.clearDisconnectAfterInactivityTimeout();
        if (transportInstance) {
            tracer.trace("Reusing already opened transport instance");
            return Promise.resolve(transportInstance);
        }
        const devicesDetectedDuringOpen = (0, hw_transport_node_hid_noevents_1.getDevices)();
        tracer.trace(`Devices detected during open: ${devicesDetectedDuringOpen.length}`, {
            devicesDetectedDuringOpen,
        });
        if (devicesDetectedDuringOpen.length === 0) {
            return Promise.reject(new errors_1.CantOpenDevice("No device found"));
        }
        const device = devicesDetectedDuringOpen[0];
        tracer.trace("Found a device, creating HID transport instance ...", { device });
        let HIDDevice;
        try {
            HIDDevice = new node_hid_1.default.HID(device.path);
        }
        catch (error) {
            tracer.trace(`Error while connecting to device: ${error}`, { error });
            return Promise.reject(error);
        }
        transportInstance = new TransportNodeHidSingleton(HIDDevice, {
            context,
        });
        const clearDeviceEventsListener = (0, listenDevices_1.listenDevices)(() => { }, () => {
            // Assumes any ledger disconnection concerns current transport
            if (transportInstance) {
                tracer.trace("Listened to on remove device event. Emitting a disconnect");
                transportInstance.emit("disconnect");
            }
        });
        /**
         * Disconnect event received from the transport instance.
         *
         * It could be after a disconnection coming from the HID library (e.g. device unplugged) or from the transport instance itself (e.g. close).
         * Clearing the singleton instance.
         * Currently, only 1 device at a time is supported.
         */
        const onDisconnect = () => {
            if (!transportInstance) {
                tracer.trace("disconnect event without transport instance, ignoring ...");
                return;
            }
            this.clearDisconnectAfterInactivityTimeout();
            transportInstance.off("disconnect", onDisconnect);
            transportInstance = null;
            clearDeviceEventsListener();
        };
        transportInstance.on("disconnect", onDisconnect);
        return Promise.resolve(transportInstance);
    }
    /**
     * Exchanges with the device using APDU protocol
     *
     * @param apdu
     * @returns a promise of apdu response
     */
    exchange(apdu) {
        return super.exchange(apdu);
    }
    /**
     * Closes the transport instance by triggering a disconnection after some inactivity (no new `open`).
     *
     * Intentionally not disconnecting the device/closing the hid connection directly:
     * The HID connection will only be closed after some inactivity.
     */
    close() {
        this.tracer.trace("Closing transport instance by triggering a disconnection after some inactivity", {
            hasInstance: !!transportInstance,
            disconnectAfterInactivityTimeoutMs: DISCONNECT_AFTER_INACTIVITY_TIMEOUT_MS,
        });
        TransportNodeHidSingleton.setDisconnectAfterInactivityTimeout();
        return Promise.resolve();
    }
}
exports.default = TransportNodeHidSingleton;
//# sourceMappingURL=TransportNodeHid.js.map