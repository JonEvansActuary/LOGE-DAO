/// <reference types="node" />
/// <reference types="node" />
import HID from "node-hid";
import TransportNodeHidNoEvents from "@ledgerhq/hw-transport-node-hid-noevents";
import type { Observer, DescriptorEvent, Subscription } from "@ledgerhq/hw-transport";
import { TraceContext } from "@ledgerhq/logs";
export type ListenDescriptorEvent = DescriptorEvent<string>;
/**
 * node-hid Transport implementation
 * @example
 * import TransportNodeHid from "@ledgerhq/hw-transport-node-hid-singleton";
 * ...
 * TransportNodeHid.create().then(transport => ...)
 */
export default class TransportNodeHidSingleton extends TransportNodeHidNoEvents {
    constructor(device: HID.HID, { context }?: {
        context?: TraceContext;
    });
    /**
     *
     */
    static isSupported: () => Promise<boolean>;
    /**
     *
     */
    static list: () => Promise<any>;
    /**
     */
    static listen: (observer: Observer<ListenDescriptorEvent>) => Subscription;
    static disconnectAfterInactivityTimeout: ReturnType<typeof setTimeout> | undefined;
    static clearDisconnectAfterInactivityTimeout(): void;
    /**
     * Disconnects device from singleton instance after some inactivity (no new `open`).
     *
     * Currently, there is only one transport instance (for only one device connected via USB).
     */
    static setDisconnectAfterInactivityTimeout(): void;
    /**
     * Disconnects from the HID device associated to the transport singleton.
     *
     * If you want to try to re-use the same transport instance at the next action (when calling `open` again), you can use
     * the transport instance `close` method: it will only enable a disconnect after some inactivity.
     */
    static disconnect(): void;
    /**
     * Connects to the first Ledger device connected via USB
     *
     * Reusing the same TransportNodeHidSingleton instance until a disconnection happens.
     * Pitfall: this implementation only handles 1 device connected via USB
     *
     * Legacy: `_descriptor` is needed to follow the Transport definition
     */
    static open(_descriptor: string, _timeoutMs?: number, context?: TraceContext): Promise<TransportNodeHidSingleton>;
    /**
     * Exchanges with the device using APDU protocol
     *
     * @param apdu
     * @returns a promise of apdu response
     */
    exchange(apdu: Buffer): Promise<Buffer>;
    /**
     * Closes the transport instance by triggering a disconnection after some inactivity (no new `open`).
     *
     * Intentionally not disconnecting the device/closing the hid connection directly:
     * The HID connection will only be closed after some inactivity.
     */
    close(): Promise<void>;
}
//# sourceMappingURL=TransportNodeHid.d.ts.map