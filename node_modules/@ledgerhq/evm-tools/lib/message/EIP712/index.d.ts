import { EIP712Message } from "@ledgerhq/types-live";
import { MessageFilters } from "./types";
export declare function isEIP712Message(message: unknown): message is EIP712Message;
export declare const sortObjectAlphabetically: (obj: Record<string, unknown>) => Record<string, unknown>;
export declare const getSchemaHashForMessage: (message: EIP712Message) => string;
/**
 * Tries to find the proper filters for a given EIP712 message
 * in the CAL
 *
 * @param {EIP712Message} message
 * @param {boolean} shouldUseV1Filters
 * @param {string | null} calServiceURL
 * @param {Record<string, any> | null | undefined} staticEIP712SignaturesV1 - Static EIP712 signatures v1 fallback
 * @param {Record<string, any> | null | undefined} staticEIP712SignaturesV2 - Static EIP712 signatures v2 fallback
 * @returns {MessageFilters | undefined}
 */
export declare const getFiltersForMessage: (message: EIP712Message, shouldUseV1Filters?: boolean, calServiceURL?: string | null, staticEIP712SignaturesV1?: Record<string, any> | null, staticEIP712SignaturesV2?: Record<string, any> | null) => Promise<MessageFilters | undefined>;
/**
 * Using a path as a string, returns the value(s) of a json key without worrying about depth or arrays
 * (e.g: 'to.wallets.[]' => ["0x123", "0x456"])
 */
export declare const getValueFromPath: (path: string, eip721Message: EIP712Message) => string | string[];
/**
 * Gets the fields visible on the nano for a specific EIP712 message
 */
export declare const getEIP712FieldsDisplayedOnNano: (messageData: EIP712Message, calServiceURL?: string, staticEIP712SignaturesV1?: Record<string, any> | null, staticEIP712SignaturesV2?: Record<string, any> | null) => Promise<{
    label: string;
    value: string | string[];
}[] | null>;
//# sourceMappingURL=index.d.ts.map