"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.identitiesSlice = void 0;
const toolkit_1 = require("@reduxjs/toolkit");
const ids_1 = require("../ids");
const types_1 = require("./types");
/**
 * Redux slice for identities management
 * Only manages DeviceIds - UserId and DatadogId are managed by apps
 */
exports.identitiesSlice = (0, toolkit_1.createSlice)({
    name: "identities",
    initialState: types_1.initialIdentitiesState,
    reducers: {
        /**
         * Initialize identities from persisted data
         */
        initFromPersisted: (state, action) => {
            state.deviceIds = action.payload.deviceIds.map(ids_1.DeviceId.fromString);
            state.pushDevicesSyncState = action.payload.pushDevicesSyncState;
            state.pushDevicesServiceUrl = action.payload.pushDevicesServiceUrl ?? null;
        },
        /**
         * Add a new device ID
         */
        addDeviceId: (state, action) => {
            const newDeviceId = action.payload;
            let exists = false;
            for (const deviceId of state.deviceIds) {
                if (deviceId.equals(newDeviceId)) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                state.deviceIds.push(newDeviceId);
                state.pushDevicesSyncState = "unsynced";
            }
        },
        /**
         * Mark sync as completed
         * @param action.payload - The API endpoint URL that was used for this sync
         */
        markSyncCompleted: (state, action) => {
            state.pushDevicesSyncState = "synced";
            state.pushDevicesServiceUrl = action.payload;
        },
    },
});
//# sourceMappingURL=slice.js.map