"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIdentitiesSyncMiddleware = void 0;
const slice_1 = require("./slice");
const api_1 = require("../api/api");
const live_env_1 = require("@ledgerhq/live-env");
/**
 * Check if identities state needs to be synced
 * Note: userId check is done in attemptSync since getUserId is async
 */
function shouldSync(state, config) {
    // Bypass sync if PUSH_DEVICES_SERVICE_URL is not configured
    const pushDevicesServiceUrl = (0, live_env_1.getEnv)("PUSH_DEVICES_SERVICE_URL");
    if (!pushDevicesServiceUrl) {
        return false;
    }
    const identitiesState = config.getIdentitiesState(state);
    const analyticsConsent = config.getAnalyticsConsent(state);
    if (!analyticsConsent) {
        return false;
    }
    if (identitiesState.deviceIds.length === 0) {
        return false;
    }
    // If the endpoint URL has changed, consider as unsynced
    if (identitiesState.pushDevicesServiceUrl !== pushDevicesServiceUrl) {
        return true;
    }
    return identitiesState.pushDevicesSyncState === "unsynced";
}
/**
 * Attempt to sync devices to the backend
 * RTK Query handles retries automatically via baseQuery retry configuration
 */
async function attemptSync(state, config, dispatch) {
    const identitiesState = config.getIdentitiesState(state);
    const userId = await config.getUserId(state);
    const analyticsConsent = config.getAnalyticsConsent(state);
    // Skip sync if no userId, no consent, or no device IDs
    if (!userId || !analyticsConsent || identitiesState.deviceIds.length === 0) {
        return;
    }
    const pushDevicesServiceUrl = (0, live_env_1.getEnv)("PUSH_DEVICES_SERVICE_URL");
    if (!pushDevicesServiceUrl) {
        // If the endpoint URL is not configured, skip sync
        return;
    }
    const request = (0, api_1.createPushDevicesRequest)(userId, identitiesState.deviceIds);
    const result = await dispatch(api_1.pushDevicesApi.endpoints.pushDevices.initiate(request));
    // RTK Query initiate returns { error } on failure or { data } on success
    if (result && typeof result === "object") {
        // Check if there's an error
        if ("error" in result && result.error) {
            // On error, state remains "unsynced" - RTK Query will retry automatically
            return;
        }
        // Success (no error) - mark as synced with the endpoint URL used
        dispatch(slice_1.identitiesSlice.actions.markSyncCompleted(pushDevicesServiceUrl));
    }
}
/**
 * Creates a Redux middleware that automatically syncs device IDs to the backend
 * whenever the identities state changes.
 *
 * @param config - Configuration for the sync middleware
 * @returns Redux middleware
 */
function createIdentitiesSyncMiddleware(config) {
    let isSyncing = false;
    function sync(state, dispatch) {
        isSyncing = true;
        attemptSync(state, config, dispatch).finally(() => {
            isSyncing = false;
        });
    }
    return store => next => action => {
        if (!isSyncing) {
            const result = next(action);
            const state = store.getState();
            if (shouldSync(state, config)) {
                sync(state, store.dispatch);
            }
            return result;
        }
        return next(action);
    };
}
exports.createIdentitiesSyncMiddleware = createIdentitiesSyncMiddleware;
//# sourceMappingURL=middleware.js.map